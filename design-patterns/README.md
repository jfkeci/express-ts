1. Singleton Pattern: This pattern ensures a class has only one instance and provides a global point of access to that instance.
2. Factory Method Pattern: This pattern provides an interface for creating objects but allows subclasses to alter the type of objects that will be created.
3. Observer Pattern: This pattern allows an object (subject) to notify its dependents (observers) about changes without knowing who or how many they are.
4. Strategy Pattern: This pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. It lets the algorithm vary independently from clients that use it.
5. Adapter Pattern: This pattern allows incompatible interfaces to work together by wrapping the object with a different interface.
6. Decorator Pattern: This pattern attaches additional responsibilities to an object dynamically. It provides a flexible alternative to subclassing for extending functionality.
7. Composite Pattern: This pattern composes objects into tree-like structures to represent part-whole hierarchies. It allows clients to treat individual objects and compositions uniformly.
8. Template Method Pattern: This pattern defines the structure of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.
9. Iterator Pattern: This pattern provides a way to access elements of a collection sequentially without exposing its underlying representation.
10. Facade Pattern: This pattern provides a unified interface to a set of interfaces in a subsystem. It simplifies a complex system by providing a higher-level interface.
11. Proxy Pattern: This pattern provides a surrogate or placeholder for another object to control access to it.
12. Command Pattern: This pattern encapsulates a request as an object, allowing parameterization of clients with different requests, queuing of requests, and logging of the requests.
13. State Pattern: This pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.
14. Interpreter Pattern: This pattern provides a way to evaluate language grammar or expressions.
15. Memento Pattern: This pattern allows an object's state to be captured and restored later without exposing its internal structure.
16. Mediator Pattern: This pattern reduces communication complexity between multiple objects by introducing a mediator object that handles all the interactions.
17. Flyweight Pattern: This pattern reduces memory usage by sharing common data between multiple objects.
18. Bridge Pattern: This pattern decouples an abstraction from its implementation, allowing both to vary independently.